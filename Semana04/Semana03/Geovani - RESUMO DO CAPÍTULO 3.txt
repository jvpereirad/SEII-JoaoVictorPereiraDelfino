  Universidade Federal de Uberlândia   FEELT – Faculdade de Engenharia Elétrica
Curso de Engenharia de Controle e Automação


 
 
 
 
RESUMO DO CAPÍTULO 3
do livro Advanced Linux Programming 
 



 



Aluno:   Geovani Almeida Estevam 	           	          	      11811EAU017


 


        

Uberlândia, 25 de outubro de 2022
1 – Analisando os Processos
1.1- IDs de processos
   Cada processo em um sistema Linux é identificado por seu ID de processo exclusivo, às vezes chamado de PID. IDs de processo são números de 16 bits atribuídos sequencialmente pelo Linux à medida que novos processos são criados.
   Todo processo também tem um processo pai. Os processos em um sistema Linux podem ser organizados como se fossem uma árvore, com o processo init em sua raiz. O ID do processo pai, ou ppid, é simplesmente o ID do processo do pai do processo.
   Ao se referir a IDs de processo em um programa C ou C++, sempre use o typedef pid_t , que é definido em <sys/types.h>. Um programa pode obter o ID do processo em que está sendo executado com a chamada de sistema getpid() , e pode obter o ID do processo de seu processo pai com a chamada de sistema getppid() . Segue exemplo abaixo, o programa na Listagem 3.1 imprime seu ID de processo e o ID de processo de seu pai.

   Figura 1 – Imprimindo o ID do Processo
   Se for rodado o programa várias vezes, será relatado um ID de processo diferente pois cada chamada está em um novo processo. No entanto, se você rodar sempre a partir do mesmo shell, o ID do processo pai, o ID do processo será o mesmo.
   
1.2- Visualizando processos ativos 

   O comando ps exibe os processos que estão sendo executados em seu sistema. A versão GNU/Linux do ps tem muitas opções porque tenta ser compatível com as versões do ps em várias outras variantes do UNIX. processos são listados e quais informações sobre cada um são mostradas. Por padrão, invocar ps exibe os processos controlados pelo terminal ou janela de terminal em que ps é invocado. Por exemplo:
   

Figura 2 – Resultado do comando ps

   Quando excutamos o comando ps mostra dois processos. O primeiro, bash, é o shell em execução neste terminal. O segundo é a instância em execução do próprio programa ps. A primeira coluna, rotulada PID, exibe o ID do processo de cada um. Em seguida uma visão mais detalhada do que está sendo executado no sistema  GNU/Linux:



Figura 3 – Resultado do comando os de forma mais detalhada



1.3- Matando um processo 
    Pode-se matar um processo em execução com o comando kill . Basta especificar na linha de comando o ID do processo a ser eliminado. Esse comando funciona enviando ao processo um SIGTERM, ou sinal de terminação.  Isso faz com que o processo termine, a menos que o programa em execução manipule ou mascare explicitamente o sinal SIGTERM . 

2. – Criando processos

2.1- Usando system 
   A função do sistema na biblioteca C padrão, fornece uma maneira fácil de executar um comando de dentro de um programa, como se o comando tivesse sido digitado em um shell. Pois é criado um subprocesso que executa o shell pradrão (/bin/sh), onde o comando roda realmente. No programa abaixo, temos um exemplo com o comando ls.


Figura 4 – Usando a chamada do sistema

   A função do sistema retorna o status de saída do comando shell. Se o próprio shell não puder ser executado, o sistema retornará 127; se ocorrer outro erro, o sistema retornará. Como a função do sistema usa um shell para invocar seu comando, ela está sujeita aos recursos, limitações e falhas de segurança do shell do sistema. Você não pode confiar na disponibilidade de nenhuma versão específica do shell Bourne. Em muitos sistemas UNIX, /bin/sh é um link simbólico para outro shell. Por exemplo, na maioria dos sistemas GNU/Linux, /bin/sh aponta para bash (o Bourne-Again SHell), e diferentes distribuições GNU/Linux usam diferentes versões do bash. Invocar um programa com privilégio de root com a função system, por exemplo, pode ter resultados diferentes em diferentes sistemas GNU/Linux. Portanto, é preferível usar o método fork e exec para criar processos.
   
2.2- Usando fork e exec 
   A API do DOS e do Windows contém a família de funções spawn. Essas funções tomam como argumento o nome de um programa a ser executado e criam uma instância de processo desse programa. 
   Chamando fork quando um programa chama fork, um processo duplicado, chamado processo filho, é criado. O processo pai continua executando o programa a partir do ponto em que fork foi chamado. O processo filho também executa o mesmo programa no mesmo lugar. 
   A figura 5 mostra um exemplo de uso de fork para duplicar o processo de um programa. Observe que o primeiro bloco da instrução if é executado apenas no processo pai, enquanto a cláusula else é executada no processo filho.


Figura 5 – Usando fork para duplicar o processo de um programa
   Usando a família exec
    As funções exec substituem o programa em execução em um processo por outro programa. Quando um programa chama uma função exec, esse processo imediatamente para de executar esse programa e começa a executar um novo programa desde o início, supondo que a chamada exec não encontre um erro.
   O argumento deve ser um array de ponteiros para strings de caracteres terminados em NULL. Cada string de caracteres deve estar no formato “VARIABLE=value”. Como exec substitui o programa chamador por outro, ele nunca retorna a menos que um ocorreu um erro.
   A lista de argumentos passada para o programa é análoga aos argumentos de linha de comando que você específica para um programa quando o executa a partir do shell. Eles estão disponíveis através dos parâmetros argc e argv para main. Lembre-se, quando um programa é invocado a partir do shell, o shell define o primeiro elemento da lista de argumentos argv[0]) para o nome do programa, o segundo elemento da lista de argumentos (argv[1]) para o primeiro comando -line argumento, e assim por diante. Quando você usa uma função exec em seus programas, você também deve passar o nome da função como o primeiro elemento da lista de argumentos.
   
   Usando fork e exec juntos 
   Um padrão comum para executar um subprograma dentro de um programa é primeiro bifurcar o processo e depois executar o subprograma, processo filho.
   

Figura 6 – Usando fork e exec juntos


2.3-  Agendamento de processos 
    O Linux agenda os processos pai e filho de maneira independente, não havendo garantias sobre qual dos dois irá rodar primeiro, ou quanto ele irá rodar até ser interrompido pelo Linux para que outro processo seja executado, porém o Linux promete que cada processo, eventualmente, será executado. Isso pode ser mudado caso seja dado um nível de prioridade ao processo, sendo o atributo determinar o “niceness value”, que quanto maior, indica menor prioridade de execução. Para atribuir tal valor, é utilizado o comando nice, e para alterar o de um programa em execução, é utilizado o comando renice.


3. Sinais 
   Sinais são mecanismos para comunicação e manipulação de processos no Linux. Um sinal é uma mensagem especial enviada a um processo. Os sinais são assíncronos; quando um processo recebe um sinal, ele processa o sinal imediatamente, sem terminar a função atual ou mesmo a linha de código atual. Existem várias dezenas de sinais diferentes, cada um com um significado diferente. Cada tipo de sinal é especificado por seu número de sinal, mas em programas, você geralmente se refere a um sinal por seu nome. No Linux, eles são definidos em / usr/include/bits/signum.h. (Você não deve incluir este arquivo de cabeçalho diretamente em seus programas; em vez disso, use <signal.h>.)


Figura 7 – Usando um manipulador de sinal
	

4. Rescisão do Processo
    Normalmente, um processo termina de duas maneiras. Ou o programa em execução chama a função exit ou a função principal do programa retorna. Cada processo tem um código de saída: um número que o processo retorna ao seu pai. O código de saída é o argumento passado para a função de saída ou o valor retornado de main.
    Ao chamar a função abort, um processo envia a si mesmo o sinal SIGABRT, que termina o processo e produz um arquivo principal. O sinal de término mais poderoso é o SIGKILL, que encerra um processo imediatamente e não pode ser bloqueado ou manipulado por um programa.
    Na figura 8, mostra-se um exemplo da função principal do fork e exec. Só que desta vez, o processo pai chama wait para esperar até que o processo filho, no qual o comando ls é executado, seja concluído.



Figura 8 – Código onde o processo pai espera o fim da execução do processo filho
    Várias chamadas de sistema semelhantes estão disponíveis no Linux, que são mais flexíveis ou fornecem mais informações sobre a saída do processo filho. A função waitpid pode ser usada para aguardar a saída de um processo filho específico em vez de qualquer processo filho. A função wait retorna CPU estatísticas de uso sobre o processo filho de saída e a função wait permite especificar opções adicionais sobre quais processos aguardar.
      
4.3 – Processos Zumbis
      Se um processo filho termina enquanto seu pai está chamando uma função de espera, o processo filho desaparece e seu status de término é passado para seu pai por meio da chamada de wait. Um processo zumbi é um processo que terminou, mas ainda não foi limpo. Isto é responsabilidade do processo pai limpar seus filhos zumbis. As funções de espera também fazem isso, portanto, não é necessário rastrear se o processo filho ainda está em execução antes de esperar por ele. Suponha, por exemplo, que um programa bifurque um processo filho, execute alguns outros cálculos e então chame wait. Se o processo filho não tiver terminado nesse ponto, o processo pai bloqueará a chamada de espera até que o processo filho termine. Se o processo filho terminar antes que o processo pai chame wait, o processo filho se torna um zumbi. Quando o processo pai chama wait, o status de término do filho zumbi é extraído, o processo filho é excluído e a chamada de espera retorna imediatamente.
      A figura 9, mostra um processo filho, que termina imediatamente e depois entra em suspensão por um minuto, sem nunca limpar o processo filho.

Figura 9 – Código onde é criado um processo zumbi

3.4.4	Limpando filhos de forma assíncrona 
    Uma solução de limpar os filhos de forma assíncrona, seria é notificar o processo pai quando um filho termina. De modo que quando um processo filho termina, o Linux envia ao processo pai o sinal SIGCHLD. A disposição padrão desse sinal é não fazer nada, e é por isso que você pode não ter notado antes.
    Assim, uma maneira fácil de limpar processos filho é manipular SIGCHLD. A figura 10 mostra o que parece para um programa usar um manipulador SIGCHLD para limpar seus processos filhos.
Figura 10 – Código onde o processo filho é limpo

    Observe como o manipulador de sinais armazena o status de saída do processo filho em uma variável global, a partir da qual o programa principal pode acessá-lo. Como a variável é atribuída em um manipulador de sinal, seu tipo é sig_atomic_t.
